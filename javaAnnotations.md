# java常用注解

### 1、transient

https://www.cnblogs.com/lanxuezaipiao/p/3369962.html

一个对象只要实现Serilizable接口，这个对象就可以被序列化。这个类的所有属性和方法都会自动序列化。

但是会有这样一种情况，这个类的有些属性需要序列化，而其他属性不需要被序列化。（如果一个用户有一些敏感信息（银行卡号，密码等），为了安全起见，不希望在网络操作中被传输，这些信息对应的变量就可以加上transient关键字。on the word，这个字段的生命周期仅存于调用者的内存中而不会写道磁盘里持久化。我们只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。

### 使用小结：

1、一旦变量被transient，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。

2、transient关键字只能修饰变量，额不能修饰类和方法。本地变量是不能被transient修饰的。变量如果是用户自定义变量，则该类需要实现Serilizable接口。

3、被transient修饰的变量不能再被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。



### 2、volatile

https://www.cnblogs.com/ustc-anmin/p/11434769.html

同步块大家都比较熟悉，通过 synchronized 关键字来实现，所有加上synchronized 和 块语句，在多线程访问的时候，同一时刻只能有一个线程能够用。synchronized 修饰的方法 或者 代码块。

##### 保证内存可见性、禁止指令重排、（不保证原子性）

一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：

　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。

**个人理解**：每个线程都有自己的存储空间，当线程在执行的时候，会从主存中把参数load一份保存到自己的存储空间，然后利用这份参数进行操作，最后写到主存中。如果主存变量发生变化，并不会影响到load到线程的那份参数。

如果加上**volatile关键字**，就会强制将修改的值立即写入主存。当线程2进行修改时，会导致线程1的工作内存中缓存变量参数的缓存无效。由于线程1中的工作内存中缓存变量参数的缓存行无效，所以线程1会再次读取主存中的变量。从而达到内存可见性。

![11172340-1b4ffc1abd6047798761edf5c5070ec1](C:\Users\刘咸鱼\Desktop\11172340-1b4ffc1abd6047798761edf5c5070ec1.jpg)

　　2）禁止进行指令重排序。

​		当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；

　　在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。











































我们秩